{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedRecordDot #-}
{-# LANGUAGE TemplateHaskellQuotes #-}

module Language.Nanopass.LangDef
  ( TypeDesc(..)
  , LangDef(..)
  , SyncatDef(..)
  , ProdDef(..)
  , Define
  , runDefine
  , defineLang
  , DefdLang(..)
  , DefdSyncatType(..)
  , DefdProd(..)
  , reifyLang
  , LangMod(..)
  , SyncatMod(..)
  , ProdMod(..)
  , runModify
  , modifyLang
  ) where

import Nanopass.Internal.LangDef

import Control.Monad (forM,forM_,foldM,when)
import Control.Monad.State (StateT,gets,modify,evalStateT)
import Data.Bifunctor (second)
import Data.Functor ((<&>))
import Data.List (nub,(\\),stripPrefix)
import Data.List.NonEmpty (NonEmpty)
import Data.Map (Map)
import Data.Maybe (fromMaybe)
import Language.Haskell.TH (Q, Dec)

import qualified Control.Monad.Trans as M
import qualified Data.Map as Map
import qualified Language.Haskell.TH as TH
import qualified Language.Haskell.TH.Syntax as TH

---------------------------------
------ Language Definition ------
---------------------------------

type Define a = StateT DefState Q a

data DefState = DefState
  { langTyvars :: [TH.Name]
  , syncatNames :: Map UpName TH.Name
  }

runDefine :: Define a -> Q a
runDefine = flip evalStateT st0
  where
  st0 = DefState
    { langTyvars = errorWithoutStackTrace "internal nanopass error: uninitialized langTyVars"
    , syncatNames = Map.empty
    }

defineLang :: LangDef -> Define [Dec]
defineLang l = do
  -- initialize language type variables
  let duplicateParams = l.langParamReqs \\ nub l.langParamReqs
  if not (null duplicateParams)
    then fail $ concat
      [ "in a nanopass language definition: "
      , "duplicate language parameter names "
      , show (nub duplicateParams)
      ]
    else modify $ \st -> st{ langTyvars = TH.mkName . fromLowName <$> l.langParamReqs }
  -- initialize syncatNames
  forM_ (syncatNameReq <$> l.syncatReqs) $ \syncatReq -> do
    knownNames <- gets syncatNames
    case Map.lookup syncatReq knownNames of
      Nothing -> modify $ \st ->
        st{syncatNames = Map.insert syncatReq (TH.mkName $ fromUpName syncatReq) knownNames}
      Just _ -> fail $ concat [ "in a nanopass language definition: "
                              , "duplicate syntactic category (terminal/nonterminal) name "
                              , fromUpName syncatReq
                              ]
  -- define a type with one nullary ctor for every grammatical type
  langInfo <- defineLanginfo l
  -- define every nonterminal type
  params <- gets langTyvars <&> \tvs -> tvs <&> \tv -> TH.PlainTV tv ()
  syncatTypeDecs <- forM l.syncatReqs $ \syn -> do
    let syncatName = TH.mkName $ fromUpName syn.syncatNameReq
    M.lift $ TH.addModFinalizer $ TH.putDoc (TH.DeclDoc syncatName) $
      "This type is a syntactic category of the t'" ++ fromUpName l.langNameReq ++ "' language."
    prodCtors <- defineProduction `mapM` syn.productionReqs
    pure $ TH.DataD [] syncatName params Nothing
            prodCtors
            []
  pure $ langInfo : syncatTypeDecs

defineLanginfo :: LangDef -> Define Dec
defineLanginfo l = do
  syncatNames <- gets $ Map.toAscList . syncatNames
  ctors <- forM syncatNames $ \(syncatName, _) -> do
    let ctorName = TH.mkName $ fromUpName l.langNameReq ++ "_" ++ fromUpName syncatName
    M.lift $ TH.addModFinalizer $ TH.putDoc (TH.DeclDoc ctorName) $
      "Serves as a reference to the syntactic category of t'" ++ fromUpName syncatName ++ "'s."
    pure $ TH.NormalC ctorName []
  let thName = TH.mkName $ fromUpName l.langNameReq
  M.lift $ TH.addModFinalizer $ TH.putDoc (TH.DeclDoc thName) $ concat
    [ unlines
      [ "This type is generated by nanopass."
      , "It serves as a reference to the types of syntactic categories in the language."
      , "Nanopass itself uses types like these to read back in a full language that was defined in a separate splice/quasiquote."
      ]
    , case (l.baseDefdLang, l.originalProgram) of
      (Just l0, Just origProg) -> unlines
        [ ""
        , "This language was generated based on the langauge t'" ++ show l0.defdLangNameTH ++ "'"
        , "using the following 'Language.Nanopass.deflang' program:"
        , ""
        , unlines . fmap ("> " ++) . lines $ origProg
        ]
      (Just l0, Nothing) -> unlines
        [ ""
        , "This language was generated based on the langauge t'" ++ show l0.defdLangNameTH ++ "'."
        ]
      (Nothing, Just origProg) -> unlines
        [ ""
        , "This language was generated from the following 'Language.Nanopass.deflang' program:"
        , ""
        , unlines . fmap ("> " ++) . lines $ origProg
        ]
      (Nothing, Nothing) -> ""
    ]
  -- I'm not sure I need these singe this type is just a glorified set of pointers, but here they are for reference
  -- dShow = TH.DerivClause Nothing [TH.ConT ''Show]
  -- dRead = TH.DerivClause Nothing [TH.ConT ''Read]
  pure $ TH.DataD [] thName [] Nothing ctors []

defineProduction :: ProdDef -> Define TH.Con
defineProduction production = do
  fields <- defineSubterm `mapM` production.subtermReqs
  pure $ TH.NormalC (TH.mkName $ fromUpName production.prodNameReq) fields

defineSubterm :: TypeDesc -> Define TH.BangType
defineSubterm typeDesc = do
  ty <- subtermType typeDesc
  pure (noBang, ty)

subtermType :: TypeDesc -> Define TH.Type
subtermType (RecursiveType syncatName) =
  gets (Map.lookup syncatName . syncatNames) >>= \case
    Just thName -> do
      let grammarCtor = TH.ConT thName
      params <- gets $ fmap TH.VarT . langTyvars
      pure $ foldl TH.AppT grammarCtor params
      -- pure $ TH.AppT grammarCtor params
    Nothing -> fail $ concat ["in a nanopass language definition: unknown metavariable ", fromUpName syncatName]
subtermType (VarType vName) =
  gets ((vName `elem`) . langTyvars) >>= \case
    True -> do
      pure $ TH.VarT vName
    False -> fail $ concat ["in a nanopass language definition: unknown langauge parameter ", show vName]
subtermType (CtorType thName argDescs) = do
  args <- subtermType `mapM` argDescs
  pure $ foldl TH.AppT (TH.ConT thName) args
subtermType (ListType argDesc) = do
  arg <- subtermType argDesc
  pure $ TH.AppT TH.ListT arg
subtermType (NonEmptyType argDesc) = do
  neType <- M.lift [t|NonEmpty|]
  arg <- subtermType argDesc
  pure $ TH.AppT neType arg
subtermType (MaybeType argDesc) = do
  maybeType <- M.lift [t|Maybe|]
  arg <- subtermType argDesc
  pure $ TH.AppT maybeType arg
subtermType (TupleType t1 t2 ts) = do
  let tupLen = 2 + length ts
      thTup = TH.TupleT tupLen
  tys <- subtermType `mapM` (t1:t2:ts)
  pure $ foldl TH.AppT thTup tys
subtermType (MapType kDesc vDesc) = do
  m <- M.lift [t|Map|]
  k <- subtermType kDesc
  v <- subtermType vDesc
  pure $ TH.AppT (TH.AppT m k) v

----------------------------------
------ Language Reification ------
----------------------------------

-- given a string, we need to find the language info with that name in scope,
-- then decode each of the info's constructors into the names of grammar types,
-- then decode each grammar type
reifyLang :: UpDotName -> Q DefdLang
reifyLang langName = do
  (defdLangNameTH, syncatPtrs) <- findLangInfo
  -- determine the language's grammar types
  thSyncats <- findRecursiveType `mapM` syncatPtrs
  let sNames = thSyncats <&> \(sName, _, _, _) -> sName
  syncatTypeList <- forM thSyncats $ \(defdSyncatName, defdSyncatNameTH, paramNames, thCtors) -> do
    ctorList <- decodeCtor sNames paramNames `mapM` thCtors
    let productions = ctorList <&> \ctor -> (ctor.defdProdName, ctor)
        prodNames = fst <$> productions
        duplicatePNames = prodNames \\ nub prodNames
    case duplicatePNames of
      [] -> pure DefdSyncatType
        { defdSyncatName
        , defdSyncatNameTH
        , defdProds = Map.fromList productions
        }
      _ -> fail $ "corrupt language has duplicate production names: " ++ show (nub duplicatePNames)
  -- disallowing duplicates here allows `decodeType.recurse` to produce `RecursiveType`s easily
  let syncatTypes = syncatTypeList <&> \t -> (t.defdSyncatName, t)
      syncatNames = fst <$> syncatTypes
      duplicateSNames = syncatNames \\ nub syncatNames
  when (not $ null duplicateSNames) $ fail $
    "corrupt language has duplicate syntactic category names: " ++ show (nub duplicateSNames)
  -- determine the language's type parameters
  defdLangParams <-
    let f Nothing (_, _, tvs, _) = pure (Just $ fixup <$> tvs)
        f (Just tvs) (_, _, tvs', _)
          | tvs == (fixup <$> tvs') = pure (Just tvs)
          | otherwise = fail $ concat
            [ "corrupt language has differing paramaters between syntactic categories. expected:\n"
            , "  " ++ show tvs ++ "\n"
            , "got:\n"
            , "  " ++ show (fixup <$> tvs')
            ]
     in fromMaybe [] <$> foldM f Nothing thSyncats
  -- and we're done
  pure $ DefdLang
    { defdLangName = langName
    , defdLangNameTH
    , defdLangParams
    , defdSyncats = Map.fromList syncatTypes
    }
  where
  -- this is here because TH will add a bunch of garbage on the end of a type variable to ensure it doesn't capture,
  -- but in this case I _want_ it to capture, so I can check name equality across different types
  fixup :: TH.Name -> TH.Name
  fixup = TH.mkName . reverse . loop . reverse . show
    where
    loop (c:rest)
      | c == '_' = rest
      | '0' <= c && c <= '9' = loop rest
    loop other = other
  decodeCtor :: [UpName] -> [TH.Name] -> TH.Con -> Q DefdProd
  decodeCtor sNames paramNames (TH.NormalC defdProdNameTH thSubterms) = do
    defdProdName <- case toUpName (TH.nameBase defdProdNameTH) of
      Just x -> pure x
      Nothing -> fail $ "corrupt language has illegal production name: " ++ show defdProdNameTH
    defdSubterms <- forM thSubterms $ \(_, thSubtermType) ->
      decodeType sNames paramNames thSubtermType
    pure $ DefdProd{defdProdName,defdProdNameTH,defdSubterms}
  decodeCtor _ _ otherCtor = fail $ "corrupt production type:\n" ++ show otherCtor
  decodeType :: [UpName] -> [TH.Name] -> TH.Type -> Q TypeDesc
  decodeType sNames paramNames type0 = recurse type0
    where
    tvs = TH.VarT <$> paramNames
    recurse tuple | Just (t1:t2:ts) <- fromTuple tuple = do
      t1Desc <- recurse t1
      t2Desc <- recurse t2
      tDescs <- recurse `mapM` ts
      pure $ TupleType t1Desc t2Desc tDescs
    recurse (TH.AppT (TH.AppT (TH.ConT special) k) v)
      | special == ''Map = MapType <$> recurse k <*> recurse v
    recurse (TH.AppT (TH.ConT special) a)
      | special == ''Maybe = MaybeType <$> recurse a
      | special == ''NonEmpty = NonEmptyType <$> recurse a
    recurse (TH.AppT TH.ListT a) = ListType <$> recurse a
    recurse appType
      | (TH.ConT thName, args) <- fromApps appType
      , Just sName <- toUpName (TH.nameBase thName)
      , sName `elem` sNames && args == tvs
        = pure $ RecursiveType sName
      | (TH.ConT thName, args) <- fromApps appType = do
        decodedArgs <- recurse `mapM` args
        pure $ CtorType thName decodedArgs
    recurse (TH.VarT a) = pure $ VarType a
    recurse otherType = fail $ "corrupt subterm type:\n" ++ show otherType ++ "\n in type:\n" ++ show type0
    fromTuple :: TH.Type -> Maybe [TH.Type]
    fromTuple t0 = case loop t0 of
      Just (0, ts) -> Just (reverse ts)
      _ -> Nothing
      where
      loop (TH.TupleT n) = Just (n, [])
      loop (TH.AppT f t)
        | Just (n, ts) <- loop f = Just (n - 1, t:ts)
      loop _ = Nothing
    fromApps :: TH.Type -> (TH.Type, [TH.Type])
    fromApps = second reverse . loop
      where
      loop (TH.AppT inner lastArg) = second (lastArg:) (loop inner)
      loop t = (t, [])
  findLangInfo :: Q (TH.Name, [TH.Con]) -- name and constructors of the info type
  findLangInfo = TH.lookupTypeName (fromUpDotName langName) >>= \case
    Nothing -> fail $ "in a nanopass language extension: could not find base language " ++ fromUpDotName langName
    Just defdLangName -> TH.reify defdLangName >>= \case
      TH.TyConI (TH.DataD [] qualThLangName [] Nothing syncatNames _) -> pure (qualThLangName, syncatNames)
      otherInfo -> fail $ concat
        [ "in a nanopass language extension: base name " ++ (fromUpName . upDotBase) langName ++ " does not identify a language: "
        , "  expecting language name to identify data definition, but got this type:\n"
        , "  " ++ show otherInfo
        ]
  findRecursiveType :: TH.Con -> Q (UpName, TH.Name, [TH.Name], [TH.Con])
  findRecursiveType (TH.NormalC thTypePtr []) = do
    let enumPrefix = (fromUpName . upDotBase) langName ++ "_"
    typePtrBase <- case stripPrefix enumPrefix (TH.nameBase thTypePtr) of
      Just base | Just it <- toUpName base -> pure it
        | otherwise -> fail $ concat
          [ "in a nanopass language extension: base name " ++ (fromUpName . upDotBase) langName ++ " is illegal: "
          , "  it must be an UpperCaseName, but got: " ++ base
          ]
      Nothing -> fail $ concat
        [ "in a nanopass language extension: base name " ++ (fromUpName . upDotBase) langName ++ " does not identify a language:\n"
        , "  expecting language info enum ctors to start with " ++ enumPrefix ++ ", but got name: "
        , "  " ++ TH.nameBase thTypePtr
        ]
    let typePtr = TH.mkName $ fromUpDotName $ upDotChBase langName typePtrBase
    TH.reify typePtr >>= \case
      TH.TyConI (TH.DataD [] defdSyncatNameTH thParams _ ctors _) -> do
        defdSyncatName <- case toUpName $ TH.nameBase defdSyncatNameTH of
          Just x -> pure x
          Nothing -> fail $ "corrupt language has illegal syntactic category name: " ++ show defdSyncatNameTH
        let thParamNames = thParams <&> \case { TH.PlainTV it _ -> it ; TH.KindedTV it _ _ -> it }
        pure (defdSyncatName, defdSyncatNameTH, thParamNames, ctors)
      otherType -> fail $ "corrupt language syntactic category type:\n" ++ show otherType
  findRecursiveType otherCtor = fail $ concat
    [ "in a nanopass language extension: base name " ++ (fromUpName . upDotBase) langName ++ " does not identify a language: "
    , "  expecting language name to identify an enum, but got this constructor:\n"
    , "  " ++ show otherCtor
    ]

--------------------------------
------ Language Extension ------
--------------------------------

runModify :: LangMod -> Q [Dec]
runModify lMod = do
  oldLang <- reifyLang (baseLangReq lMod)
  modifyLang oldLang lMod

modifyLang :: DefdLang -> LangMod -> Q [Dec]
modifyLang defd mods = do
  defd' <- restrictLang defd (syncatMods mods)
  -- TODO I think it's at this point that I can generate the default translation
  lang' <- extendLang defd' mods
  runDefine $ defineLang lang'

restrictLang :: DefdLang -> [SyncatMod] -> Q DefdLang
restrictLang = foldM doSyncat
  where
  doSyncat :: DefdLang -> SyncatMod -> Q DefdLang
  doSyncat l (AddSyncat _) = pure l
  doSyncat l (DelSyncat sName) = case Map.lookup sName l.defdSyncats of
    Just _ -> pure $ l{ defdSyncats = Map.delete sName l.defdSyncats }
    Nothing -> fail $ concat
      [ "in nanopass language extention: "
      , "attempt to delete non-existent syntactic category "
      , fromUpName sName ++ " from " ++ show (defdLangNameTH l)
      ]
  doSyncat l (ModProds sName prodMods) = case Map.lookup sName l.defdSyncats of
    Just syncat -> do
      syncat' <- foldM doProds syncat prodMods
      pure l{ defdSyncats = Map.insert sName syncat' l.defdSyncats }
    Nothing -> fail $ concat
      [ "in nanopass language extension: "
      , "attempt to modify non-existent syntactic category "
      , fromUpName sName ++ " from " ++ show (defdLangNameTH l)
      ]
    where
    doProds :: DefdSyncatType -> ProdMod -> Q DefdSyncatType
    doProds s (AddProd _) = pure s
    doProds s (DelProd pName) = case Map.lookup pName s.defdProds of
      Just _ -> pure $ s{ defdProds = Map.delete pName s.defdProds }
      Nothing -> fail $ concat
        [ "in nanopass language extention: "
        , "attempt to delete non-existent term constructor "
        , fromUpName sName ++ " from " ++ show s.defdSyncatName ++ " in " ++ show l.defdLangNameTH
        ]

extendLang :: DefdLang -> LangMod -> Q LangDef
extendLang l lMods = do
  syncatReqs0 <- doSyncat lMods.syncatMods `mapM` Map.elems l.defdSyncats
  let syncatReqs = syncatReqs0 ++ catAddSyncat lMods.syncatMods
  pure $ LangDef
    { langNameReq = lMods.newLangReq
    , langParamReqs = lMods.newParamReqs
    , syncatReqs
    , originalProgram = lMods.originalModProgram
    , baseDefdLang = Just l
    }
  where
  doSyncat :: [SyncatMod] -> DefdSyncatType -> Q SyncatDef
  doSyncat gMods DefdSyncatType{defdSyncatName,defdProds} = do
    let productionReqs0 = doProd <$> Map.elems defdProds
    let productionReqs = productionReqs0 ++ catAddProd defdSyncatName gMods
    pure SyncatDef{syncatNameReq = defdSyncatName, productionReqs}
  doProd :: DefdProd -> ProdDef
  doProd DefdProd{defdProdName, defdSubterms} =
    ProdDef defdProdName defdSubterms
  catAddSyncat (AddSyncat s : moreSMods) = s : catAddSyncat moreSMods
  catAddSyncat (_ : moreSMods) = catAddSyncat moreSMods
  catAddSyncat [] = []
  catAddProd sName (ModProds toName prodMods : moreSMods)
    | toName == sName = go prodMods ++ catAddProd sName moreSMods
    where
    go (AddProd p : morePMods) = p : go morePMods
    go (_ : morePMods) = go morePMods
    go [] = []
  catAddProd sName (_ : morePMods) = catAddProd sName morePMods
  catAddProd _ [] = []


------------------------
------ TH Helpers ------
------------------------

noBang :: TH.Bang
noBang = TH.Bang TH.NoSourceUnpackedness TH.NoSourceStrictness
